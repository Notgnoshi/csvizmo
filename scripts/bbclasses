#!/usr/bin/env python3
"""Generate a Mermaid dependency graph of all files involved in building a BitBake recipe.

Uses bb.tinfoil to parse the recipe and discover nodes (files), then manually parses
those files to discover edges (inherit/require/include relationships).
"""

import argparse
import logging
import os
import re
import sys


def parse_args():
    parser = argparse.ArgumentParser(
        description=__doc__, formatter_class=argparse.RawDescriptionHelpFormatter
    )
    parser.add_argument(
        "recipe",
        help="Recipe name (e.g. 'gzip') or path to a .bb file",
    )
    parser.add_argument(
        "--no-filter-base",
        action="store_true",
        help="Disable filtering of base BitBake infrastructure noise",
    )
    parser.add_argument(
        "--group-by-layer",
        action="store_true",
        help="Group files into Mermaid subgraphs by meta-layer",
    )
    parser.add_argument(
        "--log-level",
        "-l",
        type=str,
        default="DEBUG",
        choices=["DEBUG", "INFO", "WARNING", "ERROR", "CRITICAL"],
        help="Set the logging output level. Defaults to INFO.",
    )
    parser.add_argument(
        "--output",
        "-o",
        type=str,
        default=None,
        help="Output file. Default: stdout",
    )
    return parser.parse_args()


def parse_recipe(tinfoil, recipe):
    """Parse a recipe by name or path, returning its datastore."""
    if os.path.exists(recipe):
        logging.info("Parsing recipe file: %s", recipe)
        d = tinfoil.parse_recipe_file(recipe)
    else:
        logging.info("Parsing recipe: %s", recipe)
        d = tinfoil.parse_recipe(recipe)
    if d is None:
        sys.exit(f"Failed to parse recipe: {recipe}")
    return d


def discover_nodes(tinfoil, d):
    """Collect the set of all files involved in a recipe from the datastore."""
    recipe_file = d.getVar("FILE")
    logging.info("Recipe file: %s", recipe_file)

    inherit_cache = d.getVar("__inherit_cache") or []
    logging.info("Found %d inherited bbclasses", len(inherit_cache))
    for path in inherit_cache:
        logging.debug("  bbclass: %s", path)

    depends = d.getVar("__depends") or []
    dep_files = [
        filepath
        for filepath, _mtime in depends
        if any(filepath.endswith(ext) for ext in (".bb", ".inc", ".bbappend"))
    ]
    logging.info("Found %d file dependencies", len(dep_files))
    for path in dep_files:
        logging.debug("  dep: %s", path)

    appends = tinfoil.get_file_appends(recipe_file)
    logging.info("Found %d appends", len(appends))
    for path in appends:
        logging.debug("  append: %s", path)

    bblayers = (d.getVar("BBLAYERS") or "").split()
    common_prefix = os.path.commonpath(bblayers) + "/" if bblayers else "/"
    logging.info("Common layer prefix: %s", common_prefix)

    nodes = {recipe_file}
    nodes.update(inherit_cache)
    nodes.update(dep_files)
    nodes.update(appends)
    logging.info("Total node count: %d", len(nodes))
    return nodes, recipe_file, inherit_cache, dep_files, appends, common_prefix


# Edge discovery helpers


def preprocess(text):
    """Prepare file contents for directive scanning.

    Strips comment lines and joins backslash-continuation lines.
    """
    lines = []
    for line in text.splitlines():
        stripped = line.lstrip()
        if stripped.startswith("#"):
            continue
        lines.append(line)
    joined = "\n".join(lines)
    return joined.replace("\\\n", " ")


def build_class_lookup(inherit_cache):
    """Build a dict mapping bare class names to full paths.

    e.g. {"native": "/path/to/meta/classes/native.bbclass", ...}
    """
    lookup = {}
    for path in inherit_cache:
        basename = os.path.basename(path)
        name = basename.removesuffix(".bbclass")
        lookup[name] = path
    return lookup


def resolve_inherit(name, class_lookup):
    """Resolve an inherit class name to its full path, or None."""
    if "$" in name:
        # TODO: variable expansion
        logging.debug("Skipping variable reference in inherit: %s", name)
        return None
    result = class_lookup.get(name)
    if result is None:
        logging.debug("Could not resolve inherit: %s", name)
    return result


def resolve_include(ref, nodes):
    """Resolve a require/include path to a node in the set by suffix match, or None."""
    if "$" in ref:
        # TODO: variable expansion
        logging.debug("Skipping variable reference in include: %s", ref)
        return None
    matches = [n for n in nodes if n.endswith("/" + ref) or n == ref]
    if len(matches) == 1:
        return matches[0]
    if len(matches) > 1:
        logging.debug("Ambiguous include ref '%s', matched %d nodes", ref, len(matches))
    else:
        logging.debug("Could not resolve include: %s", ref)
    return None


def discover_edges(nodes, inherit_cache, depends):
    """Given a set of nodes, discover edges by parsing the files for directives."""
    edges = []

    return edges


BASE_FILTER_BASENAMES = {
    "base.bbclass",
    "bblayers.conf",
    "bitbake.conf",
    "documentation.bbclass",
    "insane.bbclass",
    "license.bbclass",
    "local.conf",
    "logging.bbclass",
    "metadata_scm.bbclass",
    "mirrors.bbclass",
    "patch.bbclass",
    "sanity.conf",
    "sstate.bbclass",
    "staging.bbclass",
    "utility-tasks.bbclass",
}


def filter_base_infrastructure(nodes):
    """Remove base BitBake infrastructure files that add noise to the graph."""
    filtered = set()
    for path in nodes:
        basename = os.path.basename(path)
        if basename in BASE_FILTER_BASENAMES:
            logging.debug("Filtering base infrastructure: %s", path)
            continue
        if path.endswith(".conf"):
            logging.debug("Filtering conf file: %s", path)
            continue
        filtered.add(path)
    return filtered


# Mermaid output helpers

_SANITIZE_RE = re.compile(r"[^a-zA-Z0-9_./\-]")


def sanitize_mermaid_id(path):
    """Convert a file path into a valid Mermaid node ID."""
    node_id = _SANITIZE_RE.sub("_", path)
    if node_id and node_id[0].isdigit():
        node_id = "_" + node_id
    return node_id


def escape_label(text):
    """Escape a label for use inside Mermaid quoted strings."""
    return text.replace("&", "&amp;").replace('"', "&quot;")


def strip_prefix(path, prefix):
    """Strip a common prefix from a path, returning the relative remainder."""
    if path.startswith(prefix):
        return path[len(prefix) :]
    return path


def node_shape(path, label):
    """Return the Mermaid node definition with the appropriate shape."""
    escaped = escape_label(label)
    if path.endswith(".bb"):
        return f'["{escaped}"]'
    elif path.endswith(".bbclass"):
        return f'{{{{"{escaped}"}}}}'
    elif path.endswith(".bbappend"):
        return f'(["{escaped}"])'
    elif path.endswith(".inc"):
        return f'[["{escaped}"]]'
    else:
        return f'["{escaped}"]'


def emit_mermaid(nodes, edges, common_prefix, out):
    """Write a Mermaid flowchart to the given file object."""
    out.write("flowchart TB\n")
    for path in sorted(nodes):
        path = strip_prefix(path, common_prefix)
        node_id = sanitize_mermaid_id(path)
        shape = node_shape(path, label=path)
        out.write(f"    {node_id}{shape}\n")

    for source, target, edge_type in sorted(edges):
        src_id = sanitize_mermaid_id(strip_prefix(source, common_prefix))
        tgt_id = sanitize_mermaid_id(strip_prefix(target, common_prefix))
        escaped_type = escape_label(edge_type)
        out.write(f'    {src_id} -->|"{escaped_type}"| {tgt_id}\n')


def main(args):
    try:
        import bb.tinfoil
    except ImportError:
        sys.exit(
            "Could not import bb.tinfoil. "
            "Make sure you have sourced the OE build environment "
            "(e.g. 'source oe-init-build-env')."
        )

    with bb.tinfoil.Tinfoil() as tinfoil:
        tinfoil.prepare(config_only=False)
        d = parse_recipe(tinfoil, args.recipe)
        nodes, recipe_file, inherit_cache, depends, appends, common_prefix = discover_nodes(
            tinfoil, d
        )

    if not args.no_filter_base:
        nodes = filter_base_infrastructure(nodes)

    edges = discover_edges(nodes, inherit_cache, depends)

    if args.output:
        with open(args.output, "w") as f:
            emit_mermaid(nodes, edges, common_prefix, f)
        logging.info("Wrote output to %s", args.output)
    else:
        emit_mermaid(nodes, edges, common_prefix, sys.stdout)


if __name__ == "__main__":
    args = parse_args()
    fmt = "%(asctime)s %(module)s %(levelname)s: %(message)s"
    logging.basicConfig(
        format=fmt,
        datefmt="%Y-%m-%dT%H:%M:%S%z",
        level=args.log_level,
        stream=sys.stderr,
    )
    try:
        import coloredlogs

        coloredlogs.install(fmt=fmt, level=args.log_level, datefmt="%Y-%m-%dT%H:%M:%S%z")
    except ImportError:
        pass
    main(args)
