use crate::{DepGraph, Edge};

/// Parse a makefile-style `.d` depfile into a `DepGraph`.
///
/// Each `target: dep1 dep2 ...` rule creates nodes for the target and
/// dependencies, plus edges from target -> each dependency. Supports `\`
/// line continuations and `#` comment lines.
pub fn parse(input: &str) -> eyre::Result<DepGraph> {
    let mut graph = DepGraph::default();

    // Join continuation lines first: strip trailing `\` and merge with the next line.
    let joined = join_continuations(input);

    for line in joined.lines() {
        let line = line.trim();
        if line.is_empty() || line.starts_with('#') {
            continue;
        }

        let Some(colon) = line.find(':') else {
            continue;
        };

        let target = line[..colon].trim();
        if target.is_empty() {
            continue;
        }

        ensure_node(&mut graph, target);

        for dep in line[colon + 1..].split_whitespace() {
            ensure_node(&mut graph, dep);
            graph.edges.push(Edge {
                from: target.to_string(),
                to: dep.to_string(),
                ..Default::default()
            });
        }
    }

    Ok(graph)
}

fn ensure_node(graph: &mut DepGraph, id: &str) {
    graph.nodes.entry(id.to_string()).or_default();
}

/// Join backslash-continued lines into single logical lines.
fn join_continuations(input: &str) -> String {
    let mut result = String::with_capacity(input.len());
    let mut continuation = false;

    for line in input.lines() {
        if continuation {
            // Append to the current logical line (with a space separator).
            result.push(' ');
        }

        if let Some(stripped) = line.strip_suffix('\\') {
            result.push_str(stripped);
            continuation = true;
        } else {
            result.push_str(line);
            result.push('\n');
            continuation = false;
        }
    }

    // If the last line had a trailing backslash, close it off.
    if continuation {
        result.push('\n');
    }

    result
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn empty_input() {
        let graph = parse("").unwrap();
        assert!(graph.nodes.is_empty());
        assert!(graph.edges.is_empty());
    }

    #[test]
    fn single_rule() {
        let graph = parse("main.o: main.c\n").unwrap();
        assert_eq!(graph.nodes.len(), 2);
        assert!(graph.nodes.contains_key("main.o"));
        assert!(graph.nodes.contains_key("main.c"));
        assert_eq!(graph.edges.len(), 1);
        assert_eq!(graph.edges[0].from, "main.o");
        assert_eq!(graph.edges[0].to, "main.c");
    }

    #[test]
    fn multiple_deps() {
        let graph = parse("main.o: main.c config.h utils.h\n").unwrap();
        assert_eq!(graph.nodes.len(), 4);
        assert_eq!(graph.edges.len(), 3);
        assert_eq!(graph.edges[0].to, "main.c");
        assert_eq!(graph.edges[1].to, "config.h");
        assert_eq!(graph.edges[2].to, "utils.h");
    }

    #[test]
    fn line_continuations() {
        let input = "main.o: main.c \\\n  config.h \\\n  utils.h\n";
        let graph = parse(input).unwrap();
        assert_eq!(graph.nodes.len(), 4);
        assert_eq!(graph.edges.len(), 3);
        assert_eq!(graph.edges[0].from, "main.o");
        assert_eq!(graph.edges[0].to, "main.c");
        assert_eq!(graph.edges[1].to, "config.h");
        assert_eq!(graph.edges[2].to, "utils.h");
    }

    #[test]
    fn multiple_rules() {
        let input = "a.o: a.c\nb.o: b.c\n";
        let graph = parse(input).unwrap();
        assert_eq!(graph.nodes.len(), 4);
        assert_eq!(graph.edges.len(), 2);
    }

    #[test]
    fn shared_deps_deduplicated() {
        let input = "a.o: common.h\nb.o: common.h\n";
        let graph = parse(input).unwrap();
        // common.h appears in both rules but should only be one node
        assert_eq!(graph.nodes.len(), 3);
        assert_eq!(graph.edges.len(), 2);
    }

    #[test]
    fn comment_lines_ignored() {
        let input = "# generated by gcc\nmain.o: main.c\n";
        let graph = parse(input).unwrap();
        assert_eq!(graph.nodes.len(), 2);
    }

    #[test]
    fn blank_lines_ignored() {
        let input = "\nmain.o: main.c\n\nb.o: b.c\n\n";
        let graph = parse(input).unwrap();
        assert_eq!(graph.nodes.len(), 4);
    }

    #[test]
    fn target_no_deps() {
        let input = "empty.o:\n";
        let graph = parse(input).unwrap();
        assert_eq!(graph.nodes.len(), 1);
        assert!(graph.nodes.contains_key("empty.o"));
        assert!(graph.edges.is_empty());
    }

    #[test]
    fn no_labels_or_attrs() {
        let graph = parse("a.o: a.c\n").unwrap();
        assert_eq!(graph.nodes["a.o"].label, None);
        assert!(graph.nodes["a.o"].attrs.is_empty());
        assert_eq!(graph.edges[0].label, None);
        assert!(graph.edges[0].attrs.is_empty());
    }

    #[test]
    fn preserves_node_order() {
        let input = "z.o: y.c x.h\na.o: b.c\n";
        let graph = parse(input).unwrap();
        let keys: Vec<&str> = graph.nodes.keys().map(|s| s.as_str()).collect();
        // Target first, then its deps in order, then next target and its deps
        assert_eq!(keys, vec!["z.o", "y.c", "x.h", "a.o", "b.c"]);
    }

    #[test]
    fn parse_fixture_small() {
        let input = include_str!("../../../../data/depconv/small.d");
        let graph = parse(input).unwrap();

        // Nodes: main.o, main.c, config.h, utils.h, utils.c, config.o, config.c, utils.o
        assert_eq!(graph.nodes.len(), 8);
        assert!(graph.nodes.contains_key("main.o"));
        assert!(graph.nodes.contains_key("main.c"));
        assert!(graph.nodes.contains_key("config.h"));
        assert!(graph.nodes.contains_key("utils.h"));
        assert!(graph.nodes.contains_key("utils.c"));
        assert!(graph.nodes.contains_key("config.o"));
        assert!(graph.nodes.contains_key("config.c"));
        assert!(graph.nodes.contains_key("utils.o"));

        // main.o depends on 4 files, config.o on 2, utils.o on 2
        assert_eq!(graph.edges.len(), 8);

        // Check main.o edges
        let main_deps: Vec<&str> = graph
            .edges
            .iter()
            .filter(|e| e.from == "main.o")
            .map(|e| e.to.as_str())
            .collect();
        assert_eq!(main_deps, vec!["main.c", "config.h", "utils.h", "utils.c"]);
    }

    #[test]
    fn join_continuations_basic() {
        let input = "a \\\nb \\\nc\n";
        let joined = join_continuations(input);
        assert_eq!(joined, "a  b  c\n");
    }

    #[test]
    fn join_continuations_no_backslash() {
        let input = "a\nb\n";
        let joined = join_continuations(input);
        assert_eq!(joined, "a\nb\n");
    }
}
